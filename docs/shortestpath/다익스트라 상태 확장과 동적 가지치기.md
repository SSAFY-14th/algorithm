# 커피 & 제과점 문제 해결 과정 분석

## 어떤 문제인가?

이 문제는 **동적 그래프**(Dynamic Graph)에서 최적의 집을 찾는 문제다. `init`으로 초기 도로망이 주어지고, `add` 함수로 도로가 계속 추가될 수 있다. `calculate`가 호출되면 특정 커피점, 제과점 목록과 제한 거리 `R`이 주어지는데, 우리는 다음 조건을 만족하는 집을 찾아야 한다.

-   **조건**: 집에서 가장 가까운 커피점과 제과점까지의 거리가 모두 `R` 이하여야 한다.
-   **목표**: 위 조건을 만족하는 집들 중, 두 거리의 **합이 최소**가 되는 값을 찾는 것.

여기서 가장 어려운 점은 `add` 함수 때문에 매번 최단 경로를 다시 계산해야 하고, 모든 테스트케이스를 합쳐 **누적 3초** 안에 풀어야 한다는 점이다.

## 어디서부터 탐색을 시작할까?

문제를 풀기 위해 가장 먼저 고민할 지점은 탐색의 시작점이다. 선택지는 '집' 아니면 '상점'이다.

-   **집에서 출발한다면?**
    -   집의 개수는 최대 **8,000개**에 달한다. 각 집에서 다익스트라를 실행해 가장 가까운 상점을 찾아야 하므로, 쿼리 한 번에 다익스트라를 **최대 8,000번** 실행해야 한다. 이것은 명백한 시간 초과다.

-   **상점에서 출발한다면?**
    -   상점의 개수는 최대 **2,000개**다. 집보다 훨씬 적다. 여기서 **멀티소스 다익스트라**(Multi-Source Dijkstra)를 사용하면, 모든 상점에서 출발하는 탐색을 훨씬 적은 횟수로 통합할 수 있다.

따라서 탐색의 시작점을 개수가 **더 적은 쪽**(상점)으로 잡는 것이 이 문제 해결의 첫 번째 열쇠다.

## 1. 나누어 계산하기 (2-Pass)

상점에서 출발하기로 했으니, 가장 직관적인 방법은 커피와 제과점을 따로 계산하는 것이다.

-   **아이디어**: "커피 거리 구하기"와 "제과점 거리 구하기"를 별개의 문제로 본다.
-   **구현**:
    1.  모든 커피점을 시작점으로 MSD를 1회 실행하여 `distCoffee[]`를 구한다.
    2.  모든 제과점을 시작점으로 MSD를 1회 실행하여 `distBakery[]`를 구한다.

이 **2-Pass**(2회 탐색) 방식은 쿼리마다 그래프를 두 번씩 탐색해야 해서, 누적 시간 제한을 통과하기엔 너무 느리다.

## 2. 한 번에 계산하기 (1-Pass)

**두 탐색은 서로 독립적인데, 굳이 두 번 나눠서 할 필요가 있을까? 한 번에 진행하며 결과를 따로 기록하면 되지 않을까?**

-   **통합 탐색**(1-Pass)
    -   **태그**(Tag)(`kind`)를 이용해 커피점(kind=1)과 제과점(kind=2) 경로를 구분한다.
    -   **하나의 PQ**에 두 종류의 출발지를 모두 넣고 다익스트라를 **단 1회**만 실행한다.
    -   `kind` 태그에 따라 두 개의 분리된 DP 테이블(`dp[0]`, `dp[1]`)에 결과를 기록한다.

**절반을 줄였지만, 여기서 더 최적화 할 수는 없을까? 실시간으로 갱신되는 답 후보를 이용하면 어떨까?**

-   **동적 가지치기**(Dynamic Pruning)
    -   1-Pass 접근법은 두 `dp` 배열을 동시에 채우므로, 탐색 도중에도 **답 후보**(candidate answer)를 즉시 계산할 수 있다.
    -   이 `answer` 값을 탐색의 새로운 **상한선**(upper bound)으로 사용한다.
    -   `if (newDist >= answer)` 와 같은 가지치기 코드를 통해, 현재까지 찾은 최적의 "합"보다 비효율적인 모든 경로를 탐색 대상에서 즉시 제외시킨다.

## 최종 정리

저수준의 코드 최적화(제로-객체, 스레딩 등)에 매달리기보다, 문제의 구조를 파악하여 탐색 횟수 자체를 줄이고, 탐색 과정 자체를 동적으로 최적화하는 **알고리즘 설계 능력**에 집중하자.
