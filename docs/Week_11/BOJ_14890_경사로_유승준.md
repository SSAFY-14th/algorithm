# '경사로' 문제 풀이: One-Pass & 상태 관리

## 1. 핵심 상태 변수

* `int base`: 현재 밟고 있는 **기준 평지의 높이**.
* `int stk` (streak): `base` 높이의 평지가 **몇 칸째 연속되었는지**의 길이.
    * (의미: 다음 '오르막' 경사로를 놓기 위한 '발판'의 길이)

---

## 2. 알고리즘 로직 (4가지 분기)

`for`문으로 `c`를 1부터 `N-1`까지 순회하며 `map[r][c]`와 `base`를 비교합니다.

### Case 1. `base == map[r][c]` (평지)

* `stk++`
* 연속된 평지의 길이(`stk`)를 1 증가시킵니다.

### Case 2. `base + 1 == map[r][c]` (오르막)

* **[검사]** `stk < L`
    * 지금까지 쌓인 '발판'(`stk`)이 `L`보다 짧으면, 경사로를 놓을 수 없습니다.
    * `return 0` (실패)
* **[성공]**
    * `base`를 새 높이( `base + 1` )로 갱신합니다.
    * `stk = 1` 로 초기화합니다.

### Case 3. `base - 1 == map[r][c]` (내리막)

* `base`를 새 높이( `base - 1` )로 갱신합니다.
* **[검사 1: 범위]** `if (c + L - 1 >= N)`
    * 경사로가 맵을 벗어나는지 확인합니다.
    * `return 0` (실패)
* **[검사 2: 평평함]** `for (int nc = c; nc < c + L; nc++)`
    * `c`부터 `L`개의 칸이 모두 새 `base` 높이와 같은지 확인합니다.
    * 다르면 `return 0` (실패)
* **[성공]**
    * `c += L - 1` : 경사로가 차지한 만큼 인덱스를 '점프'시킵니다.
    * `stk = 0` : 발판으로 사용 불가함을 표시합니다.

### Case 4. `Math.abs(diff) > 1` (높이 차 2 이상)

* `return 0` (즉시 실패)

---

## 3. 주의할 점: 인덱싱 & 상태 초기화

알고리즘의 정확성은 이 4가지 핵심 처리에 달려있습니다.

### Q1. 오르막(Case 2) 성공 시, 왜 `stk = 1` 인가?

* `[ 2 ][ 2 ][ 3 ]` (L=2)
* `c=2`에서 `[3]`을 만났습니다. `stk`은 2 (`>= L`)이므로 오르막 성공입니다.
* 이때 **`[3]` 자신**이 새로운 `base(3)`의 **첫 번째(1) 발판**이 됩니다.
* 따라서 `stk`는 `1`로 초기화되어야 합니다.

### Q2. 내리막(Case 3) 성공 시, 왜 `stk = 0` 인가?

* `stk`는 **'오르막'을 위한 발판**을 의미합니다. '내리막' 경사로로 사용된 땅은 이 발판이 될 수 없습니다.
* `stk = 0`은 "경사로가 방금 끝났고, 아직 새 발판은 1칸도 없다"는 상태입니다.
* **예시:** `[ 3 ][ 2 ][ 2 ][ 2 ][ 3 ]` (L=2)
    1.  `c=1`: `[2]` (내리막). `c=1, 2`의 `[2, 2]`를 경사로로 사용. `stk = 0`, `c`는 `2`로 점프.
    2.  `c=3`: `[2]` (평지). `stk`는 `1`이 됨.
    3.  `c=4`: `[3]` (오르막).
    4.  **[검사]** `stk(1) < L(2)` -> **True!**
    5.  `return 0` (실패) -> **올바른 결과입니다.** (만약 `stk=1`로 리셋했다면 `stk=2`가 되어 통과하는 오류 발생)

### Q3. 내리막(Case 3)에서 왜 `c += L - 1` 로 점프하는가?

* 경사로를 놓기 위해 `c`부터 `c + L - 1`까지 (총 `L`개 칸)을 이미 확인하고 '소모'했습니다.
* `for`문은 이번 반복이 끝나면 자동으로 `c++`를 실행합니다.
* 따라서 `(L - 1)` 만큼만 점프시키면, `for`문의 `c++`와 합쳐져 총 `L`칸을 건너뛰게 됩니다.
* 다음 반복은 `(c + L - 1) + 1` = `c + L` 인덱스, 즉 **경사로가 끝난 바로 다음 칸**부터 시작됩니다.

### Q4. 범위 검사(Case 3)가 왜 `c + L - 1 >= N` 인가?

* 맵의 크기는 `N` (인덱스는 `0` ~ `N-1`).
* 경사로의 **마지막 칸 인덱스**는 `c + L - 1` 입니다.
* 이 마지막 칸이 맵을 벗어나면 안 됩니다. (즉, `c + L - 1 <= N - 1` 이어야 함)
* 따라서 실패 조건(맵을 벗어나는 조건)은 `c + L - 1 >= N` 입니다.

---

## 4. 풀이의 장점 (요약)

* **One-Pass (`O(N)`)**: 각 행과 열을 처음부터 끝까지 단 한 번만 순회합니다. (전체 시간 복잡도: `O(N^2)`)
* **메모리 효율성 (`O(1)`)**: 경사로 설치 여부를 확인하기 위한 별도의 `visited` (방문) 배열을 사용하지 않습니다.
* **상태 변수 활용**: `base`와 `stk`라는 두 개의 정수 변수만으로 '경사로를 놓을 수 있는지'와 '발판이 몇 개인지'의 모든 상태를 관리합니다.