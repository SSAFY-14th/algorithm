

# [BOJ 12100 — 2048 (Easy)](https://www.acmicpc.net/problem/12100)

## 1) 문제 요약

* **목표**: 2048 게임 보드에서 최대 5번 이동(상·하·좌·우)을 수행했을 때 만들 수 있는 **가장 큰 타일 값**을 구하는 문제.
* **규칙**

  * 한 방향으로 기울이면 모든 블록이 해당 방향으로 이동한다.
  * 인접한 같은 숫자는 **한 번만 합쳐지고**, 합쳐진 블록은 **같은 이동 내에서 다시 합쳐질 수 없다.**
  * 이동은 각 줄(line)을 기준으로 `압축 → 병합 → 재압축` 순서로 처리된다.
* **입력 제약**

  * 보드 크기 `N ≤ 20`, 이동 횟수 최대 5회 → 완전 탐색(DFS)으로 해결 가능.

---

## 2) 문제 해결 흐름 개요

1. **탐색 방식**

   * 깊이 5까지의 **DFS(깊이 우선 탐색)** 또는 **백트래킹**으로 모든 이동 조합을 탐색한다.
   * 각 깊이마다 상/하/좌/우 4가지 방향 중 하나를 선택 → 총 경우의 수는 `4⁵ = 1024`로 충분히 탐색 가능.
2. **기울이기 동작 구현**

   * 한 방향으로 이동 시, 보드를 **줄 단위(line 단위)** 로 나누어 생각한다.
   * 각 줄에 대해 다음 순서로 처리한다:

     1. **압축**: 0을 제거하고 숫자만 순서대로 당긴다.
     2. **병합**: 인접한 두 숫자가 같으면 한 번만 합치고, 합친 후에는 다음 칸은 건너뛴다.
     3. **재압축**: 병합 후 생긴 빈칸을 뒤쪽으로 채운다.
   * 모든 방향은 인덱스 순서만 조정해서 동일한 로직으로 처리할 수 있다.

     * ← : 행을 왼→오 순서로 처리
     * → : 행을 오→왼 순서로 처리
     * ↑ : 열을 위→아래 순서로 처리
     * ↓ : 열을 아래→위 순서로 처리
3. **탐색 과정**

   * 현재 보드를 복사 → 한 방향으로 기울이기 수행.
   * 이동 결과 보드가 바뀌지 않았다면, 그 방향은 탐색하지 않는다.
   * 깊이가 5가 되면 현재 보드의 **최대 타일 값**을 기록한다.

---

## 3) 정석 알고리즘 동작 흐름

1. **DFS(depth, board)**

   * `depth == 5`이면 현재 보드의 최대 타일을 결과 후보로 저장하고 종료.
   * 아니라면 4방향(↑↓←→)을 순회하며:

     * 현재 보드를 복사한다.
     * 해당 방향으로 기울이기 수행.
     * 보드가 바뀌었다면 `DFS(depth + 1, new_board)` 호출.
2. **기울이기(board, direction)**

   * 방향에 맞게 각 줄(line)을 추출.
   * 줄을 `압축 → 병합 → 재압축` 순서로 처리한 뒤, 보드에 반영.
3. **결과 계산**

   * 모든 탐색이 끝난 후, 기록된 값 중 **가장 큰 타일**이 정답.

---

## 4) 시각화 — 이동 및 병합 과정 예시

### 🔹 왼쪽(←)으로 이동하는 경우

```
초기 상태
[ 2, 2, 0, 0 ]

1) 압축: [ 2, 2 ]
2) 병합: [ 4, 0 ]
3) 재압축: [ 4, 0, 0, 0 ]

결과
[ 4, 0, 0, 0 ]
```

---

```
초기 상태
[ 2, 2, 2, 0 ]

1) 압축: [ 2, 2, 2 ]
2) 병합: [ 4, 2, 0 ]
3) 재압축: [ 4, 2, 0, 0 ]

결과
[ 4, 2, 0, 0 ]
```

---

```
초기 상태
[ 4, 0, 4, 4 ]

1) 압축: [ 4, 4, 4 ]
2) 병합: [ 8, 4, 0 ]
3) 재압축: [ 8, 4, 0, 0 ]

결과
[ 8, 4, 0, 0 ]
```

---

### 🔹 위쪽(↑)으로 이동하는 경우

각 열을 “세로 줄(line)”로 보고 동일한 규칙 적용:

```
초기 상태 (세로 열 중 하나)
[ 2 ]
[ 0 ]
[ 2 ]
[ 2 ]

1) 압축: [ 2, 2, 2 ]
2) 병합: [ 4, 2, 0 ]
3) 재압축: [ 4, 2, 0, 0 ]

결과
[ 4 ]
[ 2 ]
[ 0 ]
[ 0 ]
```

---

### 🔹 전체 탐색 흐름 요약 (DFS 트리 형태)

```
depth 0 : 원본 보드
 ├─ ← 이동
 │   ├─ ↑ 이동
 │   ├─ ↓ 이동
 │   ├─ ← 이동
 │   └─ → 이동
 ├─ → 이동
 │   ├─ ↑ 이동
 │   ├─ ↓ 이동
 │   ├─ ← 이동
 │   └─ → 이동
 ├─ ↑ 이동
 │   ├─ ...
 └─ ↓ 이동
     ├─ ...
```

* 깊이 5까지 반복
* 각 노드마다 **보드의 최대 타일**을 기록하고, 최댓값을 갱신한다.

---

## 📘 참고

### 🔹 알고리즘 분류

* **Brute Force (완전 탐색)**
* **Backtracking (백트래킹)**
* **Simulation (시뮬레이션)**
* **Implementation (구현)**

### 🔹 관련 문제

| 번호                                                                                   | 문제명         | 유형          |
| ------------------------------------------------------------------------------------ | ----------- | ----------- |
| [BOJ 20061](https://www.acmicpc.net/problem/20061)                                   | 모노미노도미노 2   | 시뮬레이션       |
| [BOJ 13460](https://www.acmicpc.net/problem/13460)                                   | 구슬 탈출 2     | BFS + 시뮬레이션 |
| [Programmers 60059](https://school.programmers.co.kr/learn/courses/30/lessons/60059) | 자물쇠와 열쇠     | 2D 배열 회전/이동 |

### 🔹 학습 포인트

* **배열 시뮬레이션 구현 능력**
  → `압축`, `병합`, `재압축` 로직을 분리해 사고하는 훈련
* **완전 탐색 가지치기 전략**
  → “보드가 변하지 않으면 탐색 생략”을 통한 효율적 백트래킹
* **방향 정규화 사고**
  → 4방향을 “왼쪽 이동” 로직 하나로 통일하여 코드 중복 최소화

