# BOJ 14890 경사로 — 내 풀이 로직 전략

## 문제 해석을 코드 관점으로 재정렬
- 입력 격자 `arr[N][N]`를 **2N개의 1차원 선형 높이 배열**로 분해해 각각 유효 도로인지 판정한다.
  - 행 검사: `arr[i]` 그대로 전달  
  - 열 검사: `col[i] = arr[i][j]`로 세로 스캔하여 1차원 배열 구성
- 각 1차원 배열의 판정은 **단일 함수 `isOk(int[] l)`**로 일관되게 처리한다.
- 최종 답: `isOk`가 `true`인 행·열의 개수 합.

---

## 핵심 아이디어 한 줄 요약
> 인접 높이 차이를 좌→우로 주사(스캔)하면서, **오르막은 뒤쪽 M칸**, **내리막은 앞쪽 M칸**에 **한 번만 사용 가능한 경사로**를 배치할 수 있는지 체크한다. 모든 지점에서 규칙을 만족하면 해당 1차원 배열은 유효 도로다.

---

## `isOk(int[] l)`의 단계별 절차

### 0) 준비: 경사로 사용 여부 표기
- `boolean[] visit = new boolean[N]`
  - 의미: `visit[k]==true`면 **그 칸에 이미 경사로가 배치**되어, 재사용할 수 없다.
  - 역할: 경사로 **중복 배치 금지** 규칙을 지역적으로 보장하는 락(lock) 역할.

### 1) 좌→우 선형 주사
- 인덱스 `i`를 0부터 `N-2`까지 순회하며 `cur = l[i]`, `nxt = l[i+1]`의 **높이 차 `diff = nxt - cur`**를 관찰한다.
- 경우의 수는 세 가지로 축소된다.

#### (A) 평지: `diff == 0`
- 아무 조치 없이 다음 칸으로 진행.
- 불변식: **아직까지 규칙 위반 없음**을 유지.

#### (B) 오르막: `diff == 1`
- **직전 M칸**이 모두 `cur`과 동일한지 확인하고, 그 구간에 경사로가 **아직 배치되지 않았는지** 점검한다.
  - 검사 구간: `k = i, i-1, ..., i-(M-1)`
  - 검증 항목:
    - 인덱스 범위 유효성(`k >= 0`)
    - 연속성(`l[k] == cur`)
    - 미사용성(`!visit[k]`)
- 조건을 만족하면 **그 구간을 경사로로 확정**: `visit[k] = true`로 마킹.
- 직관: 오르막은 뒤를 받쳐줘야 하므로 “**뒤쪽 M칸**”이 평평하게 버텨주는 구조.

#### (C) 내리막: `diff == -1`
- **다음 M칸**이 모두 `nxt`와 동일한지 확인하고, 그 구간에 경사로가 **아직 배치되지 않았는지** 점검한다.
  - 검사 구간: `k = i+1, i+2, ..., i+M`
  - 검증 항목:
    - 인덱스 범위 유효성(`k < N`)
    - 연속성(`l[k] == nxt`)
    - 미사용성(`!visit[k]`)
- 조건을 만족하면 **그 구간을 경사로로 확정**: `visit[k] = true`로 마킹.
- 직관: 내리막은 앞으로 내려가며 안정화가 필요하므로 “**앞쪽 M칸**”이 평평하게 이어져야 한다.

#### (D) 그 외: `|diff| ≥ 2`
- 규칙상 불가능한 변화이므로 즉시 실패 판정.

### 2) 종료
- 모든 인접 쌍에 대해 위 조건을 만족하며 끝까지 진행되면 `true`를 반환한다.
- 설계 포인트: **지역적 검증의 누적**만으로 전체 경로의 유효성이 결정되도록 했다(전역 탐색 불필요).

---

## 로직의 불변식(중요 내부 규칙)
- **I1. 중복 금지 불변식:** 어떤 칸도 경사로에 **두 번 이상** 포함되지 않는다.  
  ⇒ `visit[]`로 강제.
- **I2. 연속성 불변식:** 경사로가 배치되는 M칸은 **동일 높이**로 연속한다.  
  ⇒ 오르막·내리막 각각에서 값 동일성 검사.
- **I3. 경계 안전 불변식:** 검사 구간은 항상 **배열 경계 내**에 있어야 한다.  
  ⇒ 인덱스 범위 체크로 강제.
- **I4. 단조 이동 불변식:** 스캔은 좌→우로 한 번만 진행한다.  
  ⇒ 선형 시간 보장, 로컬 판정의 전역 일관성 유지.

---

## 자료구조 선택의 이유
| 구조 | 선택 | 이유 |
|---|---|---|
| 1차원 배열 분해 | 행/열을 별도로 배열화 | **문제 정의와 동일한 모델** (각 행, 각 열 독립 판정) |
| `visit[N]` | boolean 배열 | **중복 배치 금지**를 O(1)로 체크·마킹 |
| 단순 선형 스캔 | 투 포인터 불필요 | 인접 차이만 보면 되므로 **단일 포인터**로 충분 |

---

## 시간·공간 복잡도
- **`isOk(l)`**: 각 칸을 상수번만 확인/마킹 → **O(N)**
- **전체**: 행 N개 + 열 N개 호출 → **O(N²)**
- **공간**: `visit[N]` → **O(N)**

---

## 구현 체크리스트(자체 검증용)
- [ ] 오르막 시 **뒤쪽 M칸** 검사 후 마킹
- [ ] 내리막 시 **앞쪽 M칸** 검사 후 마킹
- [ ] 각 검사에서 **경계, 연속성, 미사용** 3요소 확인
- [ ] `|diff| ≥ 2`인 경우 즉시 실패
- [ ] 모든 인접 쌍 처리 후 이상 없으면 성공

---

## 직관적 이해를 돕는 미니 요약
- 오르막은 **뒤를 받쳐야** 하고, 내리막은 **앞을 다져야** 한다.  
- 한 번 다진(경사로를 놓은) 칸은 **다시 쓸 수 없다**.  
- 이 세 문장을 코드로 풀어쓴 것이 `isOk`의 전부다.

---

## 마무리
- 본 전략은 **국소 규칙의 누적 검증**만으로 전역 유효성을 보장한다.  
- 행/열에 동일 규칙을 적용하여 **구현의 일관성**과 **선형 시간**을 모두 달성한다.  
- 별도의 반례 탐색 없이도, 경사로 배치 규칙(연속성·길이·중복 금지·경계)을 **정확히 기계적으로** 집행하는 구조다.
