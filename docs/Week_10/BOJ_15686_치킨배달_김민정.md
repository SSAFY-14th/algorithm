
# [BOJ 15686 치킨 배달 ](https://www.acmicpc.net/problem/15686)

## 1. 문제 요약

- 도시의 각 칸은 **빈 칸(0)**, **집(1)**, **치킨집(2)** 중 하나로 구성됨  
- 이 중 **M개의 치킨집만 남기고** 나머지를 폐업시킬 때, **각각의 집에서 가장 가까운 치킨집까지의 거리 합(= 도시의 치킨 거리)** 이 최소가 되도록 함
- 즉, **도시의 모든 집이 최소 거리로 치킨집에 접근할 수 있도록 조합을 선택하는 최적화 문제**
  
<br></br>    
|시간 제한| 메모리|  입력 변수 범위   |
|-------|------|------|
|1초|512MB|N(2 ≤ N ≤ 50),  M(1 ≤ M ≤ 13)|
<br></br>
---

## 2. 문제 해결 흐름 개요

1. **입력 처리**
   - 도시 크기 `N`, 남길 치킨집 개수 `M` 입력
   - 도시 정보를 2차원 배열 `map`에 저장  
   - 치킨집의 좌표를 리스트에 저장

2. **조합 생성 (백트래킹)**
   - 치킨집 중에서 `M`개를 선택하는 모든 조합 생성  
   - 선택된 조합마다 도시 치킨 거리 계산

3. **도시 치킨 거리 계산**
   - 각 집에 대해, 선택된 치킨집들과의 **맨해튼 거리**를 구하고 그 중 **최솟값**만 더함
   - 모든 집의 최소 거리를 더한 값이 해당 조합의 치킨 거리 합

4. **최소 거리 갱신**
   - 조합마다 도시 치킨 거리 합을 비교하여 `ans` 최소값 갱신
<br></br>
--- 

## 3. 본인이 푼 알고리즘 동작 흐름

### (1️) 도시 정보 저장
- `map[N][N]`에 도시 정보를 입력받음  
- 치킨집 좌표를 `List<Point> chicken`에 저장  
- `Point` 클래스는 `(r, c)` 좌표를 표현

### (2) 백트래킹으로 조합 생성
```java
static void backtrack(int start, List<Point> path) {
    if (path.size() == M) {
        combList.add(new ArrayList<>(path));
        return;
    }

    for (int i = start; i < chicken.size(); i++) {
        path.add(chicken.get(i));
        backtrack(i + 1, path);
        path.remove(path.size() - 1);
    }
}
````

* `chicken` 리스트에서 M개의 좌표를 선택하는 조합을 생성
* `combList`에 가능한 모든 조합을 저장

### (3️) 각 조합에 대한 거리 계산

* 모든 조합을 순회하며, 각 집과의 거리 합 계산
* `dist[N][N]` 배열을 사용하여 각 집의 최소 거리를 저장
* 각 치킨집에 대해 모든 집까지의 거리를 계산해 최솟값 갱신
* 전체 합 중 최소값을 `ans`로 갱신

### (4️) 결과 출력

* 모든 조합을 탐색한 후 최솟값 출력
* `System.out.println(ans);`

<br></br>

---

## 4. 개선점

### (1) 데이터 구조 개선

| 구분      | 기존                    | 개선                          |
| ------- | --------------------- | --------------------------- |
| 집 좌표 관리 | `map`을 순회하며 즉석에서 판별   | `List<Point> houses`로 별도 관리 |
| 거리 저장   | `dist[N][N]` 배열 사용    | 리스트 기반 계산으로 불필요             |
| 조합 저장   | 모든 조합을 `combList`에 저장 | 조합 생성 중 즉시 계산(on-the-fly)   |

→ **집과 치킨집을 각각 리스트로 관리**하면,
도시 전체를 매번 훑지 않고 **집 기준으로 한 번만 순회** 가능.

<br></br>

---

### (2) 거리 계산 방식 단순화

* 현재 구조에서는 `N×N` 전역 배열을 매 조합마다 초기화
* 실제로는 “집 → 치킨집” 거리만 필요하므로
  집 리스트를 기준으로 바로 최솟값 합산 가능

```java
int cityDistance(List<Point> picked) {
    int sum = 0;
    for (Point house : houses) {
        int minDist = Integer.MAX_VALUE;
        for (Point shop : picked) {
            minDist = Math.min(minDist,
                Math.abs(house.r - shop.r) + Math.abs(house.c - shop.c));
        }
        sum += minDist;
        if (sum >= ans) return sum; // 가지치기
    }
    return sum;
}
```

---

### (3) 불필요한 저장 제거

* `combList` 없이 조합 생성과 동시에 평가
* 메모리 절약 + 탐색 구조 단순화

---

### (4) 가지치기 (Pruning)

* 현재 부분합(`sum`)이 이미 `ans` 이상이면 탐색 중단
* 불필요한 하위 탐색 방지 → 평균 실행 속도 개선

---

### (5) 코드 구조화 및 네이밍

* 거리 계산 부분을 별도 메서드로 분리 → `cityDistance()`
* 변수명 명확히 구분: `shop`, `picked`, `houses` 등
* main 메서드 단순화 및 역할 분리

---




